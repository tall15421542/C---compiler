!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
ARRAY	nodeAttribute.h	/^    ARRAY$/;"	e	enum:__anonf29daa950103
ARRAY_ID	header.h	/^    ARRAY_ID, \/\/ID_NODE->child = dim$/;"	e	enum:IDENTIFIER_KIND
ARRAY_SIZE_NEGATIVE	semanticAnalysis.c	/^    ARRAY_SIZE_NEGATIVE,$/;"	e	enum:ErrorMsgKind	file:
ARRAY_SIZE_NOT_INT	semanticAnalysis.c	/^    ARRAY_SIZE_NOT_INT,$/;"	e	enum:ErrorMsgKind	file:
ARRAY_SUBSCRIPT_NOT_INT	semanticAnalysis.c	/^    ARRAY_SUBSCRIPT_NOT_INT,$/;"	e	enum:ErrorMsgKind	file:
ARRAY_TYPE_DESCRIPTOR	symbolTable.h	/^    ARRAY_TYPE_DESCRIPTOR,$/;"	e	enum:TypeDescriptorKind
ASSIGN_STMT	header.h	/^    ASSIGN_STMT, \/\/TODO:for simpler implementation, assign_expr also uses this$/;"	e	enum:STMT_KIND
AST_NODE	header.h	/^struct AST_NODE {$/;"	s
AST_NODE	header.h	/^typedef struct AST_NODE AST_NODE;$/;"	t	typeref:struct:AST_NODE
AST_TYPE	header.h	/^typedef enum AST_TYPE$/;"	g
AST_TYPE	header.h	/^} AST_TYPE;$/;"	t	typeref:enum:AST_TYPE
AST_TYPE_string	functions.c	/^char *AST_TYPE_string[] = {"PROGRAM", "GLOBAL_DECL_LIST", "GLOBAL_DECL", "DECL_LIST", "FUNCTION_/;"	v	typeref:typename:char * []
Allocate	alloc.c	/^AST_NODE *Allocate(AST_TYPE type){$/;"	f	typeref:typename:AST_NODE *
ArrayProperties	nodeAttribute.h	/^typedef struct ArrayProperties$/;"	s
ArrayProperties	nodeAttribute.h	/^} ArrayProperties;$/;"	t	typeref:struct:ArrayProperties
ArrayProperties	symbolTable.h	/^typedef struct ArrayProperties$/;"	s
ArrayProperties	symbolTable.h	/^} ArrayProperties;$/;"	t	typeref:struct:ArrayProperties
BINARY_OPERATION	header.h	/^    BINARY_OPERATION,$/;"	e	enum:EXPR_KIND
BINARY_OPERATOR	header.h	/^typedef enum BINARY_OPERATOR$/;"	g
BINARY_OPERATOR	header.h	/^} BINARY_OPERATOR;$/;"	t	typeref:enum:BINARY_OPERATOR
BINARY_OP_ADD	header.h	/^    BINARY_OP_ADD,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_AND	header.h	/^    BINARY_OP_AND,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_DIV	header.h	/^    BINARY_OP_DIV,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_EQ	header.h	/^    BINARY_OP_EQ,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_GE	header.h	/^    BINARY_OP_GE,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_GT	header.h	/^    BINARY_OP_GT,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_LE	header.h	/^    BINARY_OP_LE,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_LT	header.h	/^    BINARY_OP_LT,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_MUL	header.h	/^    BINARY_OP_MUL,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_NE	header.h	/^    BINARY_OP_NE,$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_OR	header.h	/^    BINARY_OP_OR$/;"	e	enum:BINARY_OPERATOR
BINARY_OP_SUB	header.h	/^    BINARY_OP_SUB,$/;"	e	enum:BINARY_OPERATOR
BLOCK_NODE	header.h	/^    BLOCK_NODE,$/;"	e	enum:AST_TYPE
CC	Makefile	/^CC = gcc -g$/;"	m
CONST_STRING_TYPE	header.h	/^    CONST_STRING_TYPE,\/\/for "const string"$/;"	e	enum:DATA_TYPE
CONST_VALUE_NODE	header.h	/^    CONST_VALUE_NODE, \/\/ex:1, 2, "constant string"$/;"	e	enum:AST_TYPE
CON_Type	header.h	/^typedef struct CON_Type{$/;"	s
CON_Type	header.h	/^} CON_Type;$/;"	t	typeref:struct:CON_Type
C_type	header.h	/^typedef enum C_type {INTEGERC,FLOATC,STRINGC} C_type;$/;"	g
C_type	header.h	/^typedef enum C_type {INTEGERC,FLOATC,STRINGC} C_type;$/;"	t	typeref:enum:C_type
DATA_TYPE	header.h	/^typedef enum DATA_TYPE$/;"	g
DATA_TYPE	header.h	/^} DATA_TYPE;$/;"	t	typeref:enum:DATA_TYPE
DATA_TYPE	nodeAttribute.h	/^} DATA_TYPE;$/;"	t	typeref:enum:__anonf29daa950103
DECLARATION_NODE	header.h	/^    DECLARATION_NODE,$/;"	e	enum:AST_TYPE
DECLSemanticValue	header.h	/^typedef struct DECLSemanticValue$/;"	s
DECLSemanticValue	header.h	/^} DECLSemanticValue;$/;"	t	typeref:struct:DECLSemanticValue
DECL_KIND	header.h	/^typedef enum DECL_KIND$/;"	g
DECL_KIND	header.h	/^} DECL_KIND;$/;"	t	typeref:enum:DECL_KIND
DataTypeDescriptor	nodeAttribute.h	/^typedef struct DataTypeDescriptor$/;"	s
DataTypeDescriptor	nodeAttribute.h	/^} DataTypeDescriptor;$/;"	t	typeref:struct:DataTypeDescriptor
ERROR_TYPE	header.h	/^    ERROR_TYPE$/;"	e	enum:DATA_TYPE
EXCESSIVE_ARRAY_DIM_DECLARATION	semanticAnalysis.c	/^    EXCESSIVE_ARRAY_DIM_DECLARATION,$/;"	e	enum:ErrorMsgKind	file:
EXPRSemanticValue	header.h	/^typedef struct EXPRSemanticValue$/;"	s
EXPRSemanticValue	header.h	/^} EXPRSemanticValue;$/;"	t	typeref:struct:EXPRSemanticValue
EXPR_KIND	header.h	/^typedef enum EXPR_KIND$/;"	g
EXPR_KIND	header.h	/^} EXPR_KIND;$/;"	t	typeref:enum:EXPR_KIND
EXPR_NODE	header.h	/^    EXPR_NODE,$/;"	e	enum:AST_TYPE
ElementTypeDescriptor	nodeAttribute.h	/^typedef struct DataTypeDescriptor ElementTypeDescriptor;$/;"	t	typeref:struct:DataTypeDescriptor
ErrorMsgKind	semanticAnalysis.c	/^typedef enum ErrorMsgKind$/;"	g	file:
ErrorMsgKind	semanticAnalysis.c	/^} ErrorMsgKind;$/;"	t	typeref:enum:ErrorMsgKind	file:
FLOAT	nodeAttribute.h	/^    FLOAT,$/;"	e	enum:__anonf29daa950103
FLOATC	header.h	/^typedef enum C_type {INTEGERC,FLOATC,STRINGC} C_type;$/;"	e	enum:C_type
FLOAT_PTR_TYPE	header.h	/^    FLOAT_PTR_TYPE,\/\/for parameter passing$/;"	e	enum:DATA_TYPE
FLOAT_REG	myRegister.h	/^    FLOAT_REG$/;"	e	enum:ProcessorType
FLOAT_REGISTER_COUNT	myRegister.h	/^#define FLOAT_REGISTER_COUNT /;"	d
FLOAT_TYPE	header.h	/^    FLOAT_TYPE,$/;"	e	enum:DATA_TYPE
FLOAT_WORK_REGISTER_COUNT	myRegister.h	/^#define FLOAT_WORK_REGISTER_COUNT /;"	d
FOR_STMT	header.h	/^    FOR_STMT,$/;"	e	enum:STMT_KIND
FUNCTION_CALL_STMT	header.h	/^    FUNCTION_CALL_STMT,$/;"	e	enum:STMT_KIND
FUNCTION_DECL	header.h	/^    FUNCTION_DECL,$/;"	e	enum:DECL_KIND
FUNCTION_PARAMETER_DECL	header.h	/^    FUNCTION_PARAMETER_DECL$/;"	e	enum:DECL_KIND
FUNCTION_SIGNATURE	symbolTable.h	/^    FUNCTION_SIGNATURE$/;"	e	enum:SymbolAttributeKind
FloatRegisterTable	myRegister.h	/^typedef struct FloatRegisterTable$/;"	s
FloatRegisterTable	myRegister.h	/^} FloatRegisterTable;$/;"	t	typeref:struct:FloatRegisterTable
FunctionSignature	nodeAttribute.h	/^typedef struct FunctionSignature$/;"	s
FunctionSignature	nodeAttribute.h	/^} FunctionSignature;$/;"	t	typeref:struct:FunctionSignature
FunctionSignature	symbolTable.h	/^typedef struct FunctionSignature$/;"	s
FunctionSignature	symbolTable.h	/^} FunctionSignature;$/;"	t	typeref:struct:FunctionSignature
HASH	symbolTable.c	/^int HASH(char * str) {$/;"	f	typeref:typename:int
HASH_TABLE_SIZE	symbolTable.h	/^#define HASH_TABLE_SIZE /;"	d
IDENTIFIER_KIND	header.h	/^typedef enum IDENTIFIER_KIND$/;"	g
IDENTIFIER_KIND	header.h	/^} IDENTIFIER_KIND;$/;"	t	typeref:enum:IDENTIFIER_KIND
IDENTIFIER_NODE	header.h	/^    IDENTIFIER_NODE,$/;"	e	enum:AST_TYPE
IF_STMT	header.h	/^    IF_STMT,$/;"	e	enum:STMT_KIND
INCOMPATIBLE_ARRAY_DIMENSION	semanticAnalysis.c	/^    INCOMPATIBLE_ARRAY_DIMENSION,$/;"	e	enum:ErrorMsgKind	file:
INT	nodeAttribute.h	/^    INT,$/;"	e	enum:__anonf29daa950103
INTEGERC	header.h	/^typedef enum C_type {INTEGERC,FLOATC,STRINGC} C_type;$/;"	e	enum:C_type
INT_OTHER_REGISTER_COUNT	myRegister.h	/^#define INT_OTHER_REGISTER_COUNT /;"	d
INT_PTR_TYPE	header.h	/^    INT_PTR_TYPE,\/\/for parameter passing$/;"	e	enum:DATA_TYPE
INT_REG	myRegister.h	/^    INT_REG,$/;"	e	enum:ProcessorType
INT_REGISTER_COUNT	myRegister.h	/^#define INT_REGISTER_COUNT /;"	d
INT_TYPE	header.h	/^    INT_TYPE,$/;"	e	enum:DATA_TYPE
INT_WORK_REGISTER_COUNT	myRegister.h	/^#define INT_WORK_REGISTER_COUNT /;"	d
IS_FUNCTION_NOT_VARIABLE	semanticAnalysis.c	/^    IS_FUNCTION_NOT_VARIABLE,$/;"	e	enum:ErrorMsgKind	file:
IS_TYPE_NOT_VARIABLE	semanticAnalysis.c	/^    IS_TYPE_NOT_VARIABLE,$/;"	e	enum:ErrorMsgKind	file:
IdentifierSemanticValue	header.h	/^typedef struct IdentifierSemanticValue$/;"	s
IdentifierSemanticValue	header.h	/^} IdentifierSemanticValue;$/;"	t	typeref:struct:IdentifierSemanticValue
IntRegisterTable	myRegister.h	/^typedef struct IntRegisterTable$/;"	s
IntRegisterTable	myRegister.h	/^} IntRegisterTable;$/;"	t	typeref:struct:IntRegisterTable
LEX	Makefile	/^LEX = flex$/;"	m
LIBS	Makefile	/^LIBS = -lfl $/;"	m
MAX_ARRAY_DIMENSION	header.h	/^#define MAX_ARRAY_DIMENSION /;"	d
MAX_ARRAY_DIMENSION	nodeAttribute.h	/^#define MAX_ARRAY_DIMENSION /;"	d
MAX_CODE_LINE_COUNT	printSourceFile.h	/^#define MAX_CODE_LINE_COUNT /;"	d
MAX_LINE_LENGTH	printSourceFile.h	/^#define MAX_LINE_LENGTH /;"	d
MyIntVector	myIntVector.h	/^typedef struct MyIntVector$/;"	s
MyIntVector	myIntVector.h	/^} MyIntVector;$/;"	t	typeref:struct:MyIntVector
NONEMPTY_ASSIGN_EXPR_LIST_NODE	header.h	/^    NONEMPTY_ASSIGN_EXPR_LIST_NODE,$/;"	e	enum:AST_TYPE
NONEMPTY_RELOP_EXPR_LIST_NODE	header.h	/^    NONEMPTY_RELOP_EXPR_LIST_NODE$/;"	e	enum:AST_TYPE
NONE_TYPE	header.h	/^    NONE_TYPE,\/\/for nodes like PROGRAM_NODE which has no type$/;"	e	enum:DATA_TYPE
NORMAL_ID	header.h	/^    NORMAL_ID, \/\/function Name, uninitialized scalar variable$/;"	e	enum:IDENTIFIER_KIND
NOT_ARRAY	semanticAnalysis.c	/^    NOT_ARRAY,$/;"	e	enum:ErrorMsgKind	file:
NOT_ASSIGNABLE	semanticAnalysis.c	/^    NOT_ASSIGNABLE,$/;"	e	enum:ErrorMsgKind	file:
NOT_FUNCTION_NAME	semanticAnalysis.c	/^    NOT_FUNCTION_NAME,$/;"	e	enum:ErrorMsgKind	file:
NUL_NODE	header.h	/^    NUL_NODE,$/;"	e	enum:AST_TYPE
OBJECT	Makefile	/^OBJECT = parser.tab.h parser.tab.c parser.tab.o lex.yy.c alloc.o functions.o codeGeneration.o se/;"	m
PARAMETER_TYPE_UNMATCH	semanticAnalysis.c	/^    PARAMETER_TYPE_UNMATCH,$/;"	e	enum:ErrorMsgKind	file:
PARAM_LIST_NODE	header.h	/^    PARAM_LIST_NODE,$/;"	e	enum:AST_TYPE
PASS_ARRAY_TO_SCALAR	semanticAnalysis.c	/^    PASS_ARRAY_TO_SCALAR,$/;"	e	enum:ErrorMsgKind	file:
PASS_SCALAR_TO_ARRAY	semanticAnalysis.c	/^    PASS_SCALAR_TO_ARRAY$/;"	e	enum:ErrorMsgKind	file:
PROGRAM_NODE	header.h	/^    PROGRAM_NODE,$/;"	e	enum:AST_TYPE
Parameter	nodeAttribute.h	/^typedef struct Parameter$/;"	s
Parameter	nodeAttribute.h	/^} Parameter;$/;"	t	typeref:struct:Parameter
Parameter	symbolTable.h	/^typedef struct Parameter$/;"	s
Parameter	symbolTable.h	/^} Parameter;$/;"	t	typeref:struct:Parameter
ParameterList	nodeAttribute.h	/^typedef struct ParameterList ParameterList;$/;"	t	typeref:struct:ParameterList
ParameterList	nodeAttribute.h	/^typedef struct ParameterList$/;"	s
ParameterList	nodeAttribute.h	/^} ParameterList;$/;"	t	typeref:struct:ParameterList
ProcessorType	myRegister.h	/^typedef enum ProcessorType$/;"	g
ProcessorType	myRegister.h	/^} ProcessorType;$/;"	t	typeref:enum:ProcessorType
PseudoRegisterTable	myRegister.h	/^typedef struct PseudoRegisterTable$/;"	s
PseudoRegisterTable	myRegister.h	/^} PseudoRegisterTable;$/;"	t	typeref:struct:PseudoRegisterTable
RETURN_ARRAY	semanticAnalysis.c	/^    RETURN_ARRAY,$/;"	e	enum:ErrorMsgKind	file:
RETURN_STMT	header.h	/^    RETURN_STMT,$/;"	e	enum:STMT_KIND
RETURN_TYPE_UNMATCH	semanticAnalysis.c	/^    RETURN_TYPE_UNMATCH,$/;"	e	enum:ErrorMsgKind	file:
ReturnTypeDescriptor	nodeAttribute.h	/^typedef struct TypeDescriptor ReturnTypeDescriptor;$/;"	t	typeref:struct:TypeDescriptor
SCALAR_TYPE_DESCRIPTOR	symbolTable.h	/^    SCALAR_TYPE_DESCRIPTOR,$/;"	e	enum:TypeDescriptorKind
STMTSemanticValue	header.h	/^typedef struct STMTSemanticValue$/;"	s
STMTSemanticValue	header.h	/^} STMTSemanticValue;$/;"	t	typeref:struct:STMTSemanticValue
STMT_KIND	header.h	/^typedef enum STMT_KIND$/;"	g
STMT_KIND	header.h	/^} STMT_KIND;$/;"	t	typeref:enum:STMT_KIND
STMT_LIST_NODE	header.h	/^    STMT_LIST_NODE,$/;"	e	enum:AST_TYPE
STMT_NODE	header.h	/^    STMT_NODE,$/;"	e	enum:AST_TYPE
STRINGC	header.h	/^typedef enum C_type {INTEGERC,FLOATC,STRINGC} C_type;$/;"	e	enum:C_type
STRING_OPERATION	semanticAnalysis.c	/^    STRING_OPERATION,$/;"	e	enum:ErrorMsgKind	file:
SYMBOL_IS_NOT_TYPE	semanticAnalysis.c	/^    SYMBOL_IS_NOT_TYPE,$/;"	e	enum:ErrorMsgKind	file:
SYMBOL_REDECLARE	semanticAnalysis.c	/^    SYMBOL_REDECLARE,$/;"	e	enum:ErrorMsgKind	file:
SYMBOL_TABLE_FLOAT_NAME	symbolTable.h	/^#define SYMBOL_TABLE_FLOAT_NAME /;"	d
SYMBOL_TABLE_INT_NAME	symbolTable.h	/^#define SYMBOL_TABLE_INT_NAME /;"	d
SYMBOL_TABLE_SYS_LIB_FREAD	symbolTable.h	/^#define SYMBOL_TABLE_SYS_LIB_FREAD /;"	d
SYMBOL_TABLE_SYS_LIB_READ	symbolTable.h	/^#define SYMBOL_TABLE_SYS_LIB_READ /;"	d
SYMBOL_TABLE_VOID_NAME	symbolTable.h	/^#define SYMBOL_TABLE_VOID_NAME /;"	d
SYMBOL_UNDECLARED	semanticAnalysis.c	/^    SYMBOL_UNDECLARED,$/;"	e	enum:ErrorMsgKind	file:
SymbolAttribute	symbolTable.h	/^typedef struct SymbolAttribute$/;"	s
SymbolAttribute	symbolTable.h	/^} SymbolAttribute;$/;"	t	typeref:struct:SymbolAttribute
SymbolAttributeKind	symbolTable.h	/^typedef enum SymbolAttributeKind$/;"	g
SymbolAttributeKind	symbolTable.h	/^} SymbolAttributeKind;$/;"	t	typeref:enum:SymbolAttributeKind
SymbolTable	symbolTable.h	/^typedef struct SymbolTable$/;"	s
SymbolTable	symbolTable.h	/^} SymbolTable;$/;"	t	typeref:struct:SymbolTable
SymbolTableEntry	symbolTable.h	/^typedef struct SymbolTableEntry$/;"	s
SymbolTableEntry	symbolTable.h	/^} SymbolTableEntry;$/;"	t	typeref:struct:SymbolTableEntry
TARGET	Makefile	/^TARGET = parser$/;"	m
TOO_FEW_ARGUMENTS	semanticAnalysis.c	/^    TOO_FEW_ARGUMENTS,$/;"	e	enum:ErrorMsgKind	file:
TOO_MANY_ARGUMENTS	semanticAnalysis.c	/^    TOO_MANY_ARGUMENTS,$/;"	e	enum:ErrorMsgKind	file:
TRY_TO_INIT_ARRAY	semanticAnalysis.c	/^    TRY_TO_INIT_ARRAY,$/;"	e	enum:ErrorMsgKind	file:
TYPEDEF_VOID_ARRAY	semanticAnalysis.c	/^    TYPEDEF_VOID_ARRAY,$/;"	e	enum:ErrorMsgKind	file:
TYPE_ATTRIBUTE	symbolTable.h	/^    TYPE_ATTRIBUTE,$/;"	e	enum:SymbolAttributeKind
TYPE_DECL	header.h	/^    TYPE_DECL,$/;"	e	enum:DECL_KIND
TypeDescriptor	symbolTable.h	/^typedef struct TypeDescriptor$/;"	s
TypeDescriptor	symbolTable.h	/^} TypeDescriptor;$/;"	t	typeref:struct:TypeDescriptor
TypeDescriptorKind	symbolTable.h	/^typedef enum TypeDescriptorKind$/;"	g
TypeDescriptorKind	symbolTable.h	/^} TypeDescriptorKind;$/;"	t	typeref:enum:TypeDescriptorKind
TypeSpecSemanticValue	header.h	/^typedef struct TypeSpecSemanticValue$/;"	s
TypeSpecSemanticValue	header.h	/^} TypeSpecSemanticValue;$/;"	t	typeref:struct:TypeSpecSemanticValue
UNARY_OPERATION	header.h	/^    UNARY_OPERATION$/;"	e	enum:EXPR_KIND
UNARY_OPERATOR	header.h	/^typedef enum UNARY_OPERATOR$/;"	g
UNARY_OPERATOR	header.h	/^} UNARY_OPERATOR;$/;"	t	typeref:enum:UNARY_OPERATOR
UNARY_OP_LOGICAL_NEGATION	header.h	/^    UNARY_OP_LOGICAL_NEGATION$/;"	e	enum:UNARY_OPERATOR
UNARY_OP_NEGATIVE	header.h	/^    UNARY_OP_NEGATIVE,$/;"	e	enum:UNARY_OPERATOR
UNARY_OP_POSITIVE	header.h	/^    UNARY_OP_POSITIVE,$/;"	e	enum:UNARY_OPERATOR
VARIABLE_ATTRIBUTE	symbolTable.h	/^    VARIABLE_ATTRIBUTE,$/;"	e	enum:SymbolAttributeKind
VARIABLE_DECL	header.h	/^    VARIABLE_DECL,$/;"	e	enum:DECL_KIND
VARIABLE_DECL_LIST_NODE	header.h	/^    VARIABLE_DECL_LIST_NODE,$/;"	e	enum:AST_TYPE
VOID_TYPE	header.h	/^    VOID_TYPE,$/;"	e	enum:DATA_TYPE
VOID_VARIABLE	semanticAnalysis.c	/^    VOID_VARIABLE,$/;"	e	enum:ErrorMsgKind	file:
WHILE_STMT	header.h	/^    WHILE_STMT,$/;"	e	enum:STMT_KIND
WITH_INIT_ID	header.h	/^    WITH_INIT_ID, \/\/ID_NODE->child = initial value$/;"	e	enum:IDENTIFIER_KIND
YACC	Makefile	/^YACC = bison -v$/;"	m
YACCFLAG	Makefile	/^YACCFLAG = -d$/;"	m
__HEADER_H__	header.h	/^#define __HEADER_H__$/;"	d
__MY_INT_VECTOR_H__	myIntVector.h	/^#define __MY_INT_VECTOR_H__$/;"	d
__MY_REGISTER_H__	myRegister.h	/^#define __MY_REGISTER_H__$/;"	d
__NODE_ARRTIBUTE_H__	nodeAttribute.h	/^#define __NODE_ARRTIBUTE_H__$/;"	d
__OFFSET_IN_AR_H___	offsetInAR.h	/^#define __OFFSET_IN_AR_H___$/;"	d
__PRINT_SOURCE_FILE_H__	printSourceFile.h	/^#define __PRINT_SOURCE_FILE_H__$/;"	d
__SYMBOL_TABLE_H__	symbolTable.h	/^#define __SYMBOL_TABLE_H__$/;"	d
__anonbebb0284010a	header.h	/^    {$/;"	u	struct:EXPRSemanticValue
__anonbebb0284020a	header.h	/^    {$/;"	u	struct:EXPRSemanticValue
__anonbebb0284030a	header.h	/^	union {$/;"	u	struct:CON_Type
__anonbebb0284040a	header.h	/^	union {$/;"	u	struct:AST_NODE
__anone57de939010a	symbolTable.h	/^    {$/;"	u	struct:TypeDescriptor
__anone57de939020a	symbolTable.h	/^    {$/;"	u	struct:SymbolAttribute
__anonf29daa950103	nodeAttribute.h	/^{$/;"	g
__anonf29daa95020a	nodeAttribute.h	/^    {$/;"	u	struct:DataTypeDescriptor
add_op	parser.y	/^add_op		: OP_PLUS$/;"	l
alloc.o	Makefile	/^alloc.o: alloc.c$/;"	t
arrayProperties	nodeAttribute.h	/^        ArrayProperties arrayProperties;$/;"	m	union:DataTypeDescriptor::__anonf29daa95020a	typeref:typename:ArrayProperties
arrayProperties	symbolTable.h	/^        ArrayProperties arrayProperties;\/\/kind: ARRAY_TYPE_DESCRIPTOR$/;"	m	union:TypeDescriptor::__anone57de939010a	typeref:typename:ArrayProperties
assign_expr	parser.y	/^assign_expr     : var_ref OP_ASSIGN relop_expr $/;"	l
assign_expr_list	parser.y	/^assign_expr_list : nonempty_assign_expr_list $/;"	l
attr	symbolTable.h	/^    } attr;$/;"	m	struct:SymbolAttribute	typeref:union:SymbolAttribute::__anone57de939020a
attribute	symbolTable.h	/^    SymbolAttribute* attribute;$/;"	m	struct:SymbolTableEntry	typeref:typename:SymbolAttribute *
attributeKind	symbolTable.h	/^    SymbolAttributeKind attributeKind;$/;"	m	struct:SymbolAttribute	typeref:typename:SymbolAttributeKind
binaryOp	header.h	/^        BINARY_OPERATOR binaryOp;$/;"	m	union:EXPRSemanticValue::__anonbebb0284020a	typeref:typename:BINARY_OPERATOR
block	parser.y	/^block           : decl_list stmt_list $/;"	l
capacity	myIntVector.h	/^    int capacity;$/;"	m	struct:MyIntVector	typeref:typename:int
cexpr	parser.y	/^cexpr		: cexpr OP_PLUS mcexpr $/;"	l
cfactor	parser.y	/^cfactor:	CONST $/;"	l
checkAssignOrExpr	semanticAnalysis.c	/^void checkAssignOrExpr(AST_NODE* assignOrExprRelatedNode)$/;"	f	typeref:typename:void
checkAssignmentStmt	semanticAnalysis.c	/^void checkAssignmentStmt(AST_NODE* assignmentNode)$/;"	f	typeref:typename:void
checkForStmt	semanticAnalysis.c	/^void checkForStmt(AST_NODE* forNode)$/;"	f	typeref:typename:void
checkFunctionCall	semanticAnalysis.c	/^void checkFunctionCall(AST_NODE* functionCallNode)$/;"	f	typeref:typename:void
checkIfStmt	semanticAnalysis.c	/^void checkIfStmt(AST_NODE* ifNode)$/;"	f	typeref:typename:void
checkInit	semanticAnalysis.c	/^void checkInit(AST_NODE* initNode, AST_NODE *declNode)$/;"	f	typeref:typename:void
checkParameterPassing	semanticAnalysis.c	/^void checkParameterPassing(Parameter* formalParameter, AST_NODE* actualParameter)$/;"	f	typeref:typename:void
checkReturnStmt	semanticAnalysis.c	/^void checkReturnStmt(AST_NODE* returnNode)$/;"	f	typeref:typename:void
checkWhileStmt	semanticAnalysis.c	/^void checkWhileStmt(AST_NODE* whileNode)$/;"	f	typeref:typename:void
checkWriteFunction	semanticAnalysis.c	/^void checkWriteFunction(AST_NODE* functionCallNode)$/;"	f	typeref:typename:void
child	header.h	/^	struct AST_NODE *child;$/;"	m	struct:AST_NODE	typeref:struct:AST_NODE *
clean	Makefile	/^clean:$/;"	t
closeScope	symbolTable.c	/^void closeScope()$/;"	f	typeref:typename:void
codeGen1Reg1ImmInstruction	codeGeneration.c	/^void codeGen1Reg1ImmInstruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGen2Reg1ImmInstruction	codeGeneration.c	/^void codeGen2Reg1ImmInstruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGen2Reg1ImmInstruction_64	codeGeneration.c	/^void codeGen2Reg1ImmInstruction_64(ProcessorType processorType,$/;"	f	typeref:typename:void
codeGen2RegInstruction	codeGeneration.c	/^void codeGen2RegInstruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGen3RegInstruction	codeGeneration.c	/^void codeGen3RegInstruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGenAssignOrExpr	codeGeneration.c	/^void codeGenAssignOrExpr(AST_NODE *testNode) {$/;"	f	typeref:typename:void
codeGenAssignmentStmt	codeGeneration.c	/^void codeGenAssignmentStmt(AST_NODE *assignmentStmtNode) {$/;"	f	typeref:typename:void
codeGenBlockNode	codeGeneration.c	/^void codeGenBlockNode(AST_NODE *blockNode) {$/;"	f	typeref:typename:void
codeGenCalcArrayElemenetAddress	codeGeneration.c	/^int codeGenCalcArrayElemenetAddress(AST_NODE *idNode) {$/;"	f	typeref:typename:int
codeGenCmp0Instruction	codeGeneration.c	/^void codeGenCmp0Instruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGenConstantLabel	codeGeneration.c	/^int codeGenConstantLabel(C_type constantType, void *valuePtr) {$/;"	f	typeref:typename:int
codeGenConstantReference	codeGeneration.c	/^void codeGenConstantReference(AST_NODE *constantNode) {$/;"	f	typeref:typename:void
codeGenConvertFromFloatToInt	codeGeneration.c	/^int codeGenConvertFromFloatToInt(int floatRegIndex) {$/;"	f	typeref:typename:int
codeGenConvertFromIntToFloat	codeGeneration.c	/^int codeGenConvertFromIntToFloat(int intRegIndex) {$/;"	f	typeref:typename:int
codeGenExprNode	codeGeneration.c	/^void codeGenExprNode(AST_NODE *exprNode) {$/;"	f	typeref:typename:void
codeGenExprRelatedNode	codeGeneration.c	/^void codeGenExprRelatedNode(AST_NODE *exprRelatedNode) {$/;"	f	typeref:typename:void
codeGenFPCmpInst	codeGeneration.c	/^void codeGenFPCmpInst(char *Inst, int Dist, int Op1, int Op2) {$/;"	f	typeref:typename:void
codeGenForStmt	codeGeneration.c	/^void codeGenForStmt(AST_NODE *forStmtNode) { \/*TODO*\/ }$/;"	f	typeref:typename:void
codeGenFunctionCall	codeGeneration.c	/^void codeGenFunctionCall(AST_NODE *functionCallNode) {$/;"	f	typeref:typename:void
codeGenFunctionDeclaration	codeGeneration.c	/^void codeGenFunctionDeclaration(AST_NODE *functionDeclNode) {$/;"	f	typeref:typename:void
codeGenGeneralNode	codeGeneration.c	/^void codeGenGeneralNode(AST_NODE *node) {$/;"	f	typeref:typename:void
codeGenGetBoolOfFloat	codeGeneration.c	/^void codeGenGetBoolOfFloat(int boolRegIndex, int floatRegIndex) {$/;"	f	typeref:typename:void
codeGenGlobalVariable	codeGeneration.c	/^void codeGenGlobalVariable(AST_NODE *varaibleDeclListNode) {$/;"	f	typeref:typename:void
codeGenIfStmt	codeGeneration.c	/^void codeGenIfStmt(AST_NODE *ifStmtNode) {$/;"	f	typeref:typename:void
codeGenLogicalInstruction	codeGeneration.c	/^void codeGenLogicalInstruction(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGenPrepareRegister	codeGeneration.c	/^void codeGenPrepareRegister(ProcessorType processorType, int regIndex,$/;"	f	typeref:typename:void
codeGenPrepareRegister_64	codeGeneration.c	/^void codeGenPrepareRegister_64(ProcessorType processorType, int regIndex,$/;"	f	typeref:typename:void
codeGenProgramNode	codeGeneration.c	/^void codeGenProgramNode(AST_NODE *programNode) {$/;"	f	typeref:typename:void
codeGenReturnStmt	codeGeneration.c	/^void codeGenReturnStmt(AST_NODE *returnStmtNode) {$/;"	f	typeref:typename:void
codeGenSaveToMemoryIfPsuedoRegister	codeGeneration.c	/^void codeGenSaveToMemoryIfPsuedoRegister(ProcessorType processorType,$/;"	f	typeref:typename:void
codeGenSetReg	codeGeneration.c	/^void codeGenSetReg(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGenSetReg_cond	codeGeneration.c	/^void codeGenSetReg_cond(ProcessorType processorType, char *instruction,$/;"	f	typeref:typename:void
codeGenStmtNode	codeGeneration.c	/^void codeGenStmtNode(AST_NODE *stmtNode) {$/;"	f	typeref:typename:void
codeGenVariableReference	codeGeneration.c	/^void codeGenVariableReference(AST_NODE *idNode) {$/;"	f	typeref:typename:void
codeGenWhileStmt	codeGeneration.c	/^void codeGenWhileStmt(AST_NODE *whileStmtNode) {$/;"	f	typeref:typename:void
codeGenerate	codeGeneration.c	/^void codeGenerate(AST_NODE *root) {$/;"	f	typeref:typename:void
codeGeneration.o	Makefile	/^codeGeneration.o: codeGeneration.c$/;"	t
const1	header.h	/^		CON_Type *const1;$/;"	m	union:AST_NODE::__anonbebb0284040a	typeref:typename:CON_Type *
constEvalValue	header.h	/^    } constEvalValue;$/;"	m	struct:EXPRSemanticValue	typeref:union:EXPRSemanticValue::__anonbebb0284010a
const_type	header.h	/^        C_type  const_type;$/;"	m	struct:CON_Type	typeref:typename:C_type
const_u	header.h	/^		const_u;$/;"	m	struct:CON_Type	typeref:union:CON_Type::__anonbebb0284030a
currentLevel	symbolTable.h	/^    int currentLevel;$/;"	m	struct:SymbolTable	typeref:typename:int
data	myIntVector.h	/^    int* data;$/;"	m	struct:MyIntVector	typeref:typename:int *
dataType	header.h	/^    DATA_TYPE dataType;$/;"	m	struct:AST_NODE	typeref:typename:DATA_TYPE
dataType	symbolTable.h	/^        DATA_TYPE dataType;\/\/kind: SCALAR_TYPE_DESCRIPTOR$/;"	m	union:TypeDescriptor::__anone57de939010a	typeref:typename:DATA_TYPE
decl	parser.y	/^decl		: type_decl $/;"	l
declSemanticValue	header.h	/^        DECLSemanticValue declSemanticValue;$/;"	m	union:AST_NODE::__anonbebb0284040a	typeref:typename:DECLSemanticValue
decl_list	parser.y	/^decl_list	: decl_list decl $/;"	l
declareFunction	semanticAnalysis.c	/^void declareFunction(AST_NODE* declarationNode)$/;"	f	typeref:typename:void
declareIdList	semanticAnalysis.c	/^void declareIdList(AST_NODE* declarationNode, SymbolAttributeKind isVariableOrTypeAttribute, int/;"	f	typeref:typename:void
declaredLocally	symbolTable.c	/^int declaredLocally(char* symbolName)$/;"	f	typeref:typename:int
dim_decl	parser.y	/^dim_decl	: MK_LB cexpr MK_RB $/;"	l
dim_fn	parser.y	/^dim_fn		: MK_LB expr_null MK_RB $/;"	l
dim_list	parser.y	/^dim_list	: dim_list MK_LB expr MK_RB $/;"	l
dimension	nodeAttribute.h	/^    int dimension;$/;"	m	struct:ArrayProperties	typeref:typename:int
dimension	symbolTable.h	/^    int dimension;$/;"	m	struct:ArrayProperties	typeref:typename:int
elementType	nodeAttribute.h	/^    ElementTypeDescriptor *elementType;$/;"	m	struct:ArrayProperties	typeref:typename:ElementTypeDescriptor *
elementType	symbolTable.h	/^    DATA_TYPE elementType;$/;"	m	struct:ArrayProperties	typeref:typename:DATA_TYPE
enterIntoHashTrain	symbolTable.c	/^void enterIntoHashTrain(int hashIndex, SymbolTableEntry* entry)$/;"	f	typeref:typename:void
enterSymbol	symbolTable.c	/^SymbolTableEntry* enterSymbol(char* symbolName, SymbolAttribute* attribute)$/;"	f	typeref:typename:SymbolTableEntry *
evaluateExprValue	semanticAnalysis.c	/^void evaluateExprValue(AST_NODE* exprNode)$/;"	f	typeref:typename:void
expr	parser.y	/^expr		: expr add_op term $/;"	l
exprSemanticValue	header.h	/^        EXPRSemanticValue exprSemanticValue;$/;"	m	union:AST_NODE::__anonbebb0284040a	typeref:typename:EXPRSemanticValue
expr_null	parser.y	/^expr_null	:expr $/;"	l
fValue	header.h	/^        float fValue;$/;"	m	union:EXPRSemanticValue::__anonbebb0284010a	typeref:typename:float
factor	parser.y	/^factor		: MK_LPAREN relop_expr MK_RPAREN$/;"	l
floatRegisterName	myRegister.c	/^char *floatRegisterName[] = {$/;"	v	typeref:typename:char * []
floatWorkRegisterName	myRegister.c	/^char *floatWorkRegisterName[] = {"ft6", "ft7"};$/;"	v	typeref:typename:char * []
freeRegister	myRegister.c	/^void freeRegister(ProcessorType processorType, int registerIndex) {$/;"	f	typeref:typename:void
functionSignature	symbolTable.h	/^        FunctionSignature* functionSignature;$/;"	m	union:SymbolAttribute::__anone57de939020a	typeref:typename:FunctionSignature *
function_decl	parser.y	/^function_decl	: function_head MK_LPAREN opt_param_list MK_RPAREN MK_LBRACE block MK_RBRACE$/;"	l
function_head	parser.y	/^function_head   : type ID$/;"	l
functions.o	Makefile	/^functions.o: functions.c$/;"	t
fval	header.h	/^		double  fval;$/;"	m	union:CON_Type::__anonbebb0284030a	typeref:typename:double
g_anyErrorOccur	semanticAnalysis.c	/^int g_anyErrorOccur = 0;$/;"	v	typeref:typename:int
g_codeGenOutputFp	codeGeneration.c	/^FILE *g_codeGenOutputFp = NULL;$/;"	v	typeref:typename:FILE *
g_currentFunctionName	codeGeneration.c	/^char *g_currentFunctionName = NULL;$/;"	v	typeref:typename:char *
g_deepestBlockVariableOffset	offsetInAR.c	/^int g_deepestBlockVariableOffset = 0;$/;"	v	typeref:typename:int
g_floatRegisterTable	myRegister.c	/^FloatRegisterTable g_floatRegisterTable;$/;"	v	typeref:typename:FloatRegisterTable
g_intRegisterTable	myRegister.c	/^IntRegisterTable g_intRegisterTable;$/;"	v	typeref:typename:IntRegisterTable
g_offsetInARAux	offsetInAR.c	/^int g_offsetInARAux = 0;$/;"	v	typeref:typename:int
g_pseudoRegisterBeginOffset	myRegister.c	/^int g_pseudoRegisterBeginOffset = -4;$/;"	v	typeref:typename:int
g_pseudoRegisterTable	myRegister.c	/^PseudoRegisterTable g_pseudoRegisterTable;$/;"	v	typeref:typename:PseudoRegisterTable
g_sourceFile	printSourceFile.c	/^char g_sourceFile[MAX_CODE_LINE_COUNT][MAX_LINE_LENGTH];$/;"	v	typeref:typename:char[][]
getBiggerType	semanticAnalysis.c	/^DATA_TYPE getBiggerType(DATA_TYPE dataType1, DATA_TYPE dataType2)$/;"	f	typeref:typename:DATA_TYPE
getExprOrConstValue	semanticAnalysis.c	/^void getExprOrConstValue(AST_NODE* exprOrConstNode, int* iValue, float* fValue)$/;"	f	typeref:typename:void
getLabelNumber	codeGeneration.c	/^int getLabelNumber() {$/;"	f	typeref:typename:int
getMyIntVector	myIntVector.c	/^MyIntVector* getMyIntVector(int initialCapacity)$/;"	f	typeref:typename:MyIntVector *
getPseudoRegisterCorrespondingOffset	myRegister.c	/^int getPseudoRegisterCorrespondingOffset(int pseudoRegisterIndex) {$/;"	f	typeref:typename:int
getRegister	myRegister.c	/^int getRegister(ProcessorType processorType) {$/;"	f	typeref:typename:int
getVariableSize	symbolTable.c	/^int getVariableSize(TypeDescriptor *typeDescriptor)$/;"	f	typeref:typename:int
global_decl	parser.y	/^global_decl	: decl_list function_decl$/;"	l
global_decl_list	parser.y	/^global_decl_list: global_decl_list global_decl $/;"	l
hashTable	symbolTable.h	/^    SymbolTableEntry* hashTable[HASH_TABLE_SIZE];$/;"	m	struct:SymbolTable	typeref:typename:SymbolTableEntry * []
iValue	header.h	/^        int iValue;$/;"	m	union:EXPRSemanticValue::__anonbebb0284010a	typeref:typename:int
id_list	parser.y	/^id_list		: ID $/;"	l
identifierName	header.h	/^    char *identifierName;$/;"	m	struct:IdentifierSemanticValue	typeref:typename:char *
identifierSemanticValue	header.h	/^        IdentifierSemanticValue identifierSemanticValue;$/;"	m	union:AST_NODE::__anonbebb0284040a	typeref:typename:IdentifierSemanticValue
init_id	parser.y	/^init_id		: ID $/;"	l
init_id_list	parser.y	/^init_id_list	: init_id $/;"	l
initializeRegisterTable	myRegister.c	/^void initializeRegisterTable() {$/;"	f	typeref:typename:void
initializeSymbolTable	symbolTable.c	/^void initializeSymbolTable()$/;"	f	typeref:typename:void
intOtherRegisterName_64	myRegister.c	/^char *intOtherRegisterName_64[] = {"s2", "s3", "s4",  "s5",  "s6", "s7",$/;"	v	typeref:typename:char * []
intRegisterName	myRegister.c	/^char *intRegisterName[] = {"t0", "t1", "t2", "t3", "t4"};$/;"	v	typeref:typename:char * []
intRegisterName_64	myRegister.c	/^char *intRegisterName_64[] = {"t0", "t1", "t2", "t3", "t4"};$/;"	v	typeref:typename:char * []
intWorkRegisterName	myRegister.c	/^char *intWorkRegisterName[] = {"t5", "t6"};$/;"	v	typeref:typename:char * []
intWorkRegisterName_64	myRegister.c	/^char *intWorkRegisterName_64[] = {"t5", "t6"};$/;"	v	typeref:typename:char * []
intval	header.h	/^		int     intval;$/;"	m	union:CON_Type::__anonbebb0284030a	typeref:typename:int
is64	myRegister.h	/^    int is64[INT_REGISTER_COUNT];$/;"	m	struct:IntRegisterTable	typeref:typename:int[]
isAllocated	myRegister.h	/^    int isAllocated[FLOAT_REGISTER_COUNT];$/;"	m	struct:FloatRegisterTable	typeref:typename:int[]
isAllocated	myRegister.h	/^    int isAllocated[INT_REGISTER_COUNT];$/;"	m	struct:IntRegisterTable	typeref:typename:int[]
isAllocatedVector	myRegister.h	/^    MyIntVector* isAllocatedVector;$/;"	m	struct:PseudoRegisterTable	typeref:typename:MyIntVector *
isConstEval	header.h	/^    int isConstEval;$/;"	m	struct:EXPRSemanticValue	typeref:typename:int
isGlobalVariable	symbolTable.c	/^int isGlobalVariable(SymbolTableEntry* symbolTableEntry)$/;"	f	typeref:typename:int
kind	header.h	/^    DECL_KIND kind;$/;"	m	struct:DECLSemanticValue	typeref:typename:DECL_KIND
kind	header.h	/^    EXPR_KIND kind;$/;"	m	struct:EXPRSemanticValue	typeref:typename:EXPR_KIND
kind	header.h	/^    IDENTIFIER_KIND kind;$/;"	m	struct:IdentifierSemanticValue	typeref:typename:IDENTIFIER_KIND
kind	header.h	/^    STMT_KIND kind;$/;"	m	struct:STMTSemanticValue	typeref:typename:STMT_KIND
kind	symbolTable.h	/^    TypeDescriptorKind kind;$/;"	m	struct:TypeDescriptor	typeref:typename:TypeDescriptorKind
leftmostSibling	header.h	/^	struct AST_NODE *leftmostSibling;$/;"	m	struct:AST_NODE	typeref:struct:AST_NODE *
lex.yy.c	Makefile	/^lex.yy.c: lexer3.l$/;"	t
linenumber	header.h	/^	int linenumber;$/;"	m	struct:AST_NODE	typeref:typename:int
mcexpr	parser.y	/^mcexpr		: mcexpr OP_TIMES cfactor $/;"	l
mul_op	parser.y	/^mul_op		: OP_TIMES$/;"	l
myIntVector.o	Makefile	/^myIntVector.o: myIntVector.c$/;"	t
myPopBack	myIntVector.c	/^void myPopBack(MyIntVector* myIntVector)$/;"	f	typeref:typename:void
myPushBack	myIntVector.c	/^void myPushBack(MyIntVector* myIntVector, int val)$/;"	f	typeref:typename:void
myRegister.o	Makefile	/^myRegister.o: myRegister.c$/;"	t
name	symbolTable.h	/^    char* name;$/;"	m	struct:SymbolTableEntry	typeref:typename:char *
nestingLevel	symbolTable.h	/^    int nestingLevel;$/;"	m	struct:SymbolTableEntry	typeref:typename:int
newSymbolTableEntry	symbolTable.c	/^SymbolTableEntry* newSymbolTableEntry(int nestingLevel)$/;"	f	typeref:typename:SymbolTableEntry *
next	nodeAttribute.h	/^    struct ParameterList* next;$/;"	m	struct:ParameterList	typeref:struct:ParameterList *
next	symbolTable.h	/^    struct Parameter* next;$/;"	m	struct:Parameter	typeref:struct:Parameter *
nextInHashChain	symbolTable.h	/^    struct SymbolTableEntry* nextInHashChain;$/;"	m	struct:SymbolTableEntry	typeref:struct:SymbolTableEntry *
nextInSameLevel	symbolTable.h	/^    struct SymbolTableEntry* nextInSameLevel;$/;"	m	struct:SymbolTableEntry	typeref:struct:SymbolTableEntry *
nodeType	header.h	/^	AST_TYPE nodeType;$/;"	m	struct:AST_NODE	typeref:typename:AST_TYPE
nonempty_assign_expr_list	parser.y	/^nonempty_assign_expr_list        : nonempty_assign_expr_list MK_COMMA assign_expr $/;"	l
nonempty_relop_expr_list	parser.y	/^nonempty_relop_expr_list	: nonempty_relop_expr_list MK_COMMA relop_expr$/;"	l
offsetInAR	symbolTable.h	/^    int offsetInAR;$/;"	m	struct:SymbolAttribute	typeref:typename:int
offsetInAR.o	Makefile	/^offsetInAR.o: offsetInAR.c$/;"	t
op	header.h	/^    } op;$/;"	m	struct:EXPRSemanticValue	typeref:union:EXPRSemanticValue::__anonbebb0284020a
openScope	symbolTable.c	/^void openScope()$/;"	f	typeref:typename:void
opt_param_list	parser.y	/^opt_param_list  : param_list$/;"	l
param	parser.y	/^param		: type ID $/;"	l
param_list	parser.y	/^param_list	: param_list MK_COMMA  param $/;"	l
parameter	nodeAttribute.h	/^    Parameter parameter;$/;"	m	struct:ParameterList	typeref:typename:Parameter
parameterList	nodeAttribute.h	/^    ParameterList* parameterList;$/;"	m	struct:FunctionSignature	typeref:typename:ParameterList *
parameterList	symbolTable.h	/^    Parameter* parameterList;$/;"	m	struct:FunctionSignature	typeref:typename:Parameter *
parameterName	symbolTable.h	/^    char* parameterName;$/;"	m	struct:Parameter	typeref:typename:char *
parametersCount	nodeAttribute.h	/^    int parametersCount;$/;"	m	struct:FunctionSignature	typeref:typename:int
parametersCount	symbolTable.h	/^    int parametersCount;$/;"	m	struct:FunctionSignature	typeref:typename:int
parent	header.h	/^	struct AST_NODE *parent;$/;"	m	struct:AST_NODE	typeref:struct:AST_NODE *
parser	Makefile	/^parser: parser.tab.o alloc.o functions.o symbolTable.o semanticAnalysis.o codeGeneration.o myReg/;"	t
parser.tab.c	Makefile	/^parser.tab.c: parser.y $/;"	t
parser.tab.o	Makefile	/^parser.tab.o: parser.tab.c lex.yy.c alloc.o functions.c symbolTable.o semanticAnalysis.o codeGen/;"	t
prevInHashChain	symbolTable.h	/^    struct SymbolTableEntry* prevInHashChain;$/;"	m	struct:SymbolTableEntry	typeref:struct:SymbolTableEntry *
printCommentError	printSourceFile.c	/^int printCommentError = 0;$/;"	v	typeref:typename:int
printErrorMsg	semanticAnalysis.c	/^void printErrorMsg(AST_NODE* node, ErrorMsgKind errorMsgKind)$/;"	f	typeref:typename:void
printErrorMsgSpecial	semanticAnalysis.c	/^void printErrorMsgSpecial(AST_NODE* node1, char* name2, ErrorMsgKind errorMsgKind)$/;"	f	typeref:typename:void
printGV	functions.c	/^void printGV(AST_NODE *root, char* fileName)$/;"	f	typeref:typename:void
printGVNode	functions.c	/^int printGVNode(FILE *fp, AST_NODE* node, int count)$/;"	f	typeref:typename:int
printLabelString	functions.c	/^char *printLabelString(FILE *fp, AST_NODE *astNode)$/;"	f	typeref:typename:char *
printRestoreRegister	myRegister.c	/^void printRestoreRegister(FILE *codeGenOutputFp) {$/;"	f	typeref:typename:void
printSourceFile	printSourceFile.c	/^void printSourceFile(FILE* outputFp, int lineNumber)$/;"	f	typeref:typename:void
printSourceFile.o	Makefile	/^printSourceFile.o: printSourceFile.c$/;"	t
printStoreRegister	myRegister.c	/^void printStoreRegister(FILE *codeGenOutputFp) {$/;"	f	typeref:typename:void
processBlockNode	semanticAnalysis.c	/^void processBlockNode(AST_NODE* blockNode)$/;"	f	typeref:typename:void
processConstValueNode	semanticAnalysis.c	/^void processConstValueNode(AST_NODE* constValueNode)$/;"	f	typeref:typename:void
processDeclDimList	semanticAnalysis.c	/^void processDeclDimList(AST_NODE* idNode, TypeDescriptor* typeDescriptor, int ignoreFirstDimSize/;"	f	typeref:typename:void
processDeclarationNode	semanticAnalysis.c	/^void processDeclarationNode(AST_NODE* declarationNode)$/;"	f	typeref:typename:void
processExprNode	semanticAnalysis.c	/^void processExprNode(AST_NODE* exprNode)$/;"	f	typeref:typename:void
processExprRelatedNode	semanticAnalysis.c	/^void processExprRelatedNode(AST_NODE* exprRelatedNode)$/;"	f	typeref:typename:void
processGeneralNode	semanticAnalysis.c	/^void processGeneralNode(AST_NODE *node)$/;"	f	typeref:typename:void
processProgramNode	semanticAnalysis.c	/^void processProgramNode(AST_NODE *programNode)$/;"	f	typeref:typename:void
processStmtNode	semanticAnalysis.c	/^void processStmtNode(AST_NODE* stmtNode)$/;"	f	typeref:typename:void
processTypeNode	semanticAnalysis.c	/^void processTypeNode(AST_NODE* idNodeAsType)$/;"	f	typeref:typename:void
processVariableLValue	semanticAnalysis.c	/^void processVariableLValue(AST_NODE* idNode)$/;"	f	typeref:typename:void
processVariableRValue	semanticAnalysis.c	/^void processVariableRValue(AST_NODE* idNode)$/;"	f	typeref:typename:void
program	parser.y	/^program		: global_decl_list { $$=Allocate(PROGRAM_NODE);  makeChild($$,$1); prog=$$;}$/;"	l
properties	nodeAttribute.h	/^    } properties;$/;"	m	struct:DataTypeDescriptor	typeref:union:DataTypeDescriptor::__anonf29daa95020a
properties	symbolTable.h	/^    } properties;$/;"	m	struct:TypeDescriptor	typeref:union:TypeDescriptor::__anone57de939010a
readSourceFile	printSourceFile.c	/^void readSourceFile(char* fileName)$/;"	f	typeref:typename:void
registerIndex	header.h	/^        int registerIndex;$/;"	m	struct:AST_NODE	typeref:typename:int
rel_op	parser.y	/^rel_op		: OP_EQ$/;"	l
relop_expr	parser.y	/^relop_expr	: relop_term $/;"	l
relop_expr_list	parser.y	/^relop_expr_list	: nonempty_relop_expr_list $/;"	l
relop_factor	parser.y	/^relop_factor	: expr$/;"	l
relop_term	parser.y	/^relop_term	: relop_factor $/;"	l
removeFromHashTrain	symbolTable.c	/^void removeFromHashTrain(int hashIndex, SymbolTableEntry* entry)$/;"	f	typeref:typename:void
removeSymbol	symbolTable.c	/^void removeSymbol(char* symbolName)$/;"	f	typeref:typename:void
resetOffsetCalculation	offsetInAR.c	/^void resetOffsetCalculation()$/;"	f	typeref:typename:void
resetRegisterTable	myRegister.c	/^void resetRegisterTable(int maxLocalVariableOffset) {$/;"	f	typeref:typename:void
retrieveSymbol	symbolTable.c	/^SymbolTableEntry* retrieveSymbol(char* symbolName)$/;"	f	typeref:typename:SymbolTableEntry *
returnType	nodeAttribute.h	/^    DataTypeDescriptor *returnType;$/;"	m	struct:FunctionSignature	typeref:typename:DataTypeDescriptor *
returnType	symbolTable.h	/^    DATA_TYPE returnType;$/;"	m	struct:FunctionSignature	typeref:typename:DATA_TYPE
rightSibling	header.h	/^	struct AST_NODE *rightSibling;$/;"	m	struct:AST_NODE	typeref:struct:AST_NODE *
sameNameInOuterLevel	symbolTable.h	/^    struct SymbolTableEntry* sameNameInOuterLevel;$/;"	m	struct:SymbolTableEntry	typeref:struct:SymbolTableEntry *
sc	header.h	/^		char    *sc; }$/;"	m	union:CON_Type::__anonbebb0284030a	typeref:typename:char *
scopeDisplay	symbolTable.h	/^    SymbolTableEntry** scopeDisplay;$/;"	m	struct:SymbolTable	typeref:typename:SymbolTableEntry **
scopeDisplayElementCount	symbolTable.h	/^    int scopeDisplayElementCount;$/;"	m	struct:SymbolTable	typeref:typename:int
semanticAnalysis	semanticAnalysis.c	/^void semanticAnalysis(AST_NODE *root)$/;"	f	typeref:typename:void
semanticAnalysis.o	Makefile	/^semanticAnalysis.o: semanticAnalysis.c$/;"	t
semantic_value	header.h	/^	} semantic_value;$/;"	m	struct:AST_NODE	typeref:union:AST_NODE::__anonbebb0284040a
setOffsetAndUpdateGlobalOffset	offsetInAR.c	/^void setOffsetAndUpdateGlobalOffset(SymbolAttribute* attribute)$/;"	f	typeref:typename:void
size	myIntVector.h	/^    int size;$/;"	m	struct:MyIntVector	typeref:typename:int
sizeInEachDimension	nodeAttribute.h	/^    int sizeInEachDimension[MAX_ARRAY_DIMENSION];$/;"	m	struct:ArrayProperties	typeref:typename:int[]
sizeInEachDimension	symbolTable.h	/^    int sizeInEachDimension[MAX_ARRAY_DIMENSION];$/;"	m	struct:ArrayProperties	typeref:typename:int[]
stmt	parser.y	/^stmt		: MK_LBRACE block MK_RBRACE $/;"	l
stmtSemanticValue	header.h	/^        STMTSemanticValue stmtSemanticValue;$/;"	m	union:AST_NODE::__anonbebb0284040a	typeref:typename:STMTSemanticValue
stmt_list	parser.y	/^stmt_list	: stmt_list stmt $/;"	l
symbolTable	symbolTable.c	/^SymbolTable symbolTable;$/;"	v	typeref:typename:SymbolTable
symbolTable.o	Makefile	/^symbolTable.o: symbolTable.c$/;"	t
symbolTableEnd	symbolTable.c	/^void symbolTableEnd()$/;"	f	typeref:typename:void
symbolTableEntry	header.h	/^    struct SymbolTableEntry *symbolTableEntry;$/;"	m	struct:IdentifierSemanticValue	typeref:struct:SymbolTableEntry *
term	parser.y	/^term		: term mul_op factor$/;"	l
test	parser.y	/^test		: assign_expr$/;"	l
type	nodeAttribute.h	/^    DATA_TYPE type;$/;"	m	struct:DataTypeDescriptor	typeref:typename:DATA_TYPE
type	nodeAttribute.h	/^    DataTypeDescriptor* type;$/;"	m	struct:Parameter	typeref:typename:DataTypeDescriptor *
type	parser.y	/^type		: INT $/;"	l
type	symbolTable.h	/^    TypeDescriptor* type;$/;"	m	struct:Parameter	typeref:typename:TypeDescriptor *
typeDescriptor	symbolTable.h	/^        TypeDescriptor* typeDescriptor;$/;"	m	union:SymbolAttribute::__anone57de939020a	typeref:typename:TypeDescriptor *
typeName	header.h	/^    char *typeName;$/;"	m	struct:TypeSpecSemanticValue	typeref:typename:char *
type_decl	parser.y	/^type_decl 	: TYPEDEF type id_list MK_SEMICOLON  $/;"	l
unaryOp	header.h	/^        UNARY_OPERATOR unaryOp;$/;"	m	union:EXPRSemanticValue::__anonbebb0284020a	typeref:typename:UNARY_OPERATOR
var_decl	parser.y	/^var_decl	: type init_id_list MK_SEMICOLON $/;"	l
var_ref	parser.y	/^var_ref		: ID $/;"	l
zeroRegisterName	myRegister.c	/^char *zeroRegisterName = "zero";$/;"	v	typeref:typename:char *
